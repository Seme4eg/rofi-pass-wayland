#!/usr/bin/env bash

# rofi-pass
# (c) 2015 Rasmus Steinke <rasi@xssn.at>
basecommand="$0"

_rofi () {
	rofi -no-auto-select -i -dmenu "$@"
}

_pwgen () {
	pwgen -y "$@"
}

_image_viewer () {
	feh -
}

config_dir=${XDG_CONFIG_HOME:-$HOME/.config}

# We expect to find these fields in pass(1)'s output
URL_field='url'
USERNAME_field='user'
AUTOTYPE_field='autotype'
OTPmethod_field='otp_method'

default_autotype="user :tab pass"
delay=2
wait=0.2
type_delay=12
# menu, copyPass, typeUser, typePass, copyUser, copyUrl, viewEntry, typeMenu,
# actionMenu, copyMenu, openUrl
default_do='menu'
auto_enter='false'
notify='false'
clip=primary
clip_clear=45
default_user="${ROFI_PASS_DEFAULT_USER-$(whoami)}"
default_user2=john_doe
password_length=12

# default shortcuts
autotype="Alt+1"
type_user="Alt+2"
type_pass="Alt+3"
open_url="Alt+4"
type_otp="Alt+5"
copy_name="Alt+u"
copy_url="Alt+l"
copy_pass="Alt+p"
show="Alt+o"
copy_menu="Alt+c"
action_menu="Alt+a"
type_menu="Alt+t"
help="Alt+h"
switch="Alt+x"
insert_pass="Alt+n"
qrcode="Alt+q"
previous_root="Shift+Left"
next_root="Shift+Right"

# Safe permissions
umask 077

# Backends for clipboard manipulation
clip_in_primary() {
	wl-copy -p
}

clip_in_clipboard() {
	wl-copy
}

clip_out_primary() {
	wl-paste -p
}

clip_out_clipboard() {
	wl-paste
}

# Backends for typing what's in stdin

do_type() {
	wtype -d ${type_delay} -
}

# Backends for pressing the key specified by the first argument ($1)

do_press_key() {
	wtype -P "$1" -p "$1"
}

notify_on() {
	if [[ $notify == "true" ]]; then
		return 0
	else
		return 1
	fi
}

# wrapper for notify-send, can be redefined in config
_notify() {
	notify-send -e "rofi-pass" "$1"
}

has_qrencode() {
	command -v qrencode >/dev/null 2>&1
}

assert_status() {
	[ "$1" -eq 1 ] && exit
}

listgpg () {
	mapfile -d '' pw_list < <(find -L . -name '*.gpg' -print0)
	pw_list=("${pw_list[@]#./}")
	printf '%s\n' "${pw_list[@]}" | sort -n
}

# get all password files and output as newline-delimited text
list_passwords() {
	cd "${root}" || exit
	mapfile -t pw_list < <(listgpg)
	printf '%s\n' "${pw_list[@]%.gpg}" | sort -n
}

doClip () {
	case "$clip" in
		"primary") clip_in_primary ;;
		"clipboard") clip_in_clipboard ;;
		"both") clip_in_primary; clip_out_primary | clip_in_clipboard;;
	esac
}


autopass () {
	local passentry="$1"
	for word in ${stuff["$AUTOTYPE_field"]}; do
		case "$word" in
			":tab") do_press_key Tab;;
			":space") do_press_key space;;
			":delay") sleep "${delay}";;
			":enter") do_press_key Return;;
			":otp") printf '%s' "$(generateOTP "$passentry")" | do_type;;
			"pass") printf '%s' "${password}" | do_type;;
			"path")
				printf '%s' "${passentry}" | rev | cut -d'/' -f1 | rev | do_type
				;;
			*) printf '%s' "${stuff[${word}]}" | do_type;;
		esac
	done

	if [[ ${auto_enter} == "true" ]]; then
		do_press_key Return
	fi

	clearUp
}

generateQrCode() {
	local passentry="$1"

	if ! has_qrencode; then
		printf '%s\n' "qrencode not found" | _rofi
		assert_status $?
		"${basecommand}"
	fi

	pass "$passentry" | head -n 1 | qrencode -d 300 -v 8 -l H -o - |
		_image_viewer

	if [ $? -eq 1 ]; then
		printf '%s\n' "" |
			_rofi -mesg "Image viewer not defined or cannot read from pipe"
		assert_status $?
		"${basecommand}"
	fi
	clearUp
}

openURL () {
	local passentry="$1"
	url=$(pass "$passentry" | grep "${URL_field}: " |
			  gawk '{sub(/:/,"")}{print $2}1' | head -1)
	[ -z "$url" ] && exit
	$BROWSER "$url"

	clearUp
}

typeUser () {
	printf '%s' "${stuff[${USERNAME_field}]}" | do_type
	clearUp
}

typePass () {
	printf '%s' "${password}" | do_type

	if notify_on || [[ "${stuff[notify]}" == "true" ]]; then
		_notify "finished typing password";
	fi

	clearUp
}

typeField () {
	local to_type
	local passentry="$1"

	case $typefield in
		"OTP") to_type="$(generateOTP "$passentry")" ;;
		*) to_type="${stuff[${typefield}]}" ;;
	esac

	printf '%s' "$to_type" | do_type

	unset to_type

	clearUp
}

generateOTP () {
	local passentry="$1"

	# First, we check if there is a non-conventional OTP command in the pass file
	_check_otp_cmd() {
		pass "$passentry" | grep -q "${OTPmethod_field}: "
	}

	if _check_otp_cmd; then
		# We execute the commands after otp_method: AS-IS
		bash -c "$(_check_otp_cmd)"
	else
		# If there is no method defined, fallback to pass-otp
		pass otp "$passentry"
	fi

	clearUp
}

copyField () {
	printf '%s' "${stuff[$1]}" | doClip
	clearUp
}

clearClip() {
	sleep $clip_clear
	printf '%s' "" | clip_in_primary
	printf '%s' "" | clip_in_clipboard
	notify_on && _notify "Clipboard cleared"
}

copyPass () {
	printf '%s' "$password" | doClip
	notify_on &&
		_notify "Copied Password\\nClearing in $clip_clear seconds"

	clearClip &
}

viewEntry () {
	showEntry "$1"
}

generatePass () {
	local passentry="$1"
	askmenu_content=("Yes" "No")
	askGenMenu=$(printf '%s\n' "${askmenu_content[@]}" |
					 _rofi -p "Generate new Password for ${selected_password}? > ")

	assert_status $?

	if [[ $askGenMenu == "Yes" ]]; then
		true
	elif [[ $askGenMenu == "No" ]]; then
		actionMenu "$1"
	fi

	symbols_content=("0  Cancel" "1  Yes" "2  No")
	symbols=$(printf '%s\n' "${symbols_content[@]}" | _rofi -p "Use Symbols? > ")
	assert_status $?

	if [[ $symbols == "0  Cancel" ]]; then
		mainMenu;
	elif [[ $symbols == "1  Yes" ]]; then
		symbols="";
	elif [[ $symbols == "2  No" ]]; then
		symbols="-n";
	fi

	HELP="Enter Number or hit Enter to use default length"
	length=$(printf '%s' "" |
				 _rofi -mesg "${HELP}" \
					 -p "Password length? (Default: ${password_length}) > ")
	assert_status $?

	if [[ $length == "" ]]; then
		PASSWORD_STORE_DIR="${root}" pass generate ${symbols} -i \
			"$passentry" "${password_length}" > /dev/null;
	else
		PASSWORD_STORE_DIR="${root}" pass generate ${symbols} -i \
			"$passentry" "${length}" > /dev/null;
	fi
}

mainMenu () {
	local passentry
	if [[ $1 == "--bmarks" ]]; then
		passentry="$(list_passwords 2>/dev/null \
			| _rofi -mesg "Bookmarks Mode. ${switch} to switch" \
			-kb-custom-10 "${switch}" \
			-select "$entry" \
			-p "rofi-pass > ")"

		case $? in
			1) exit ;;
			19) ${basecommand} ;;
			0) openURL "$passentry" ;;
		esac
	else
		unset passentry

		args=(
			-kb-custom-1 "${autotype}"
			-kb-custom-2 "${type_user}"
			-kb-custom-3 "${type_pass}"
			-kb-custom-4 "${open_url}"
			-kb-custom-5 "${copy_name}"
			-kb-custom-6 "${copy_pass}"
			-kb-custom-7 "${show}"
			-kb-custom-8 "${copy_url}"
			-kb-custom-9 "${type_menu}"
			-kb-custom-10 "${previous_root}"
			-kb-custom-11 "${next_root}"
			-kb-custom-12 "${type_otp}"
			-kb-custom-14 "${action_menu}"
			-kb-custom-15 "${copy_menu}"
			-kb-custom-16 "${help}"
			-kb-custom-17 "${switch}"
			-kb-custom-18 "${insert_pass}"
			-kb-custom-19 "${qrcode}"

			# These keyboard shortcut options are needed, because
			# Shift+<Left|Right> are otherwise taken by rofi.
			-kb-mode-previous ""
			-kb-mode-next ""
			-select "$entry"
			-p "> "
		)

		if [[ ${#roots[@]} -gt "1" || $custom_root == "true" ]]; then
			args+=(-mesg "PW Store: ${root}")
		fi

		passentry="$(list_passwords 2>/dev/null | _rofi "${args[@]}")"

		rofi_exit=$?

		# Actions based on exit code, which do not need the entry.
		# The exit code for -kb-custom-X is X+9.
		case $rofi_exit in
			1) exit ;;
			19)
				roots_index=$(( (roots_index-1+roots_length) % roots_length))
				root=${roots[$roots_index]}
				mainMenu
				return
				;;
			20)
				roots_index=$(( (roots_index+1) % roots_length))
				root=${roots[$roots_index]}
				mainMenu
				return
				;;
			25) helpMenu; return;;
			26) ${basecommand} --bmarks; return;;
		esac

		# get an array of password file fields like url: user: and custom ones
		local -a password_temp
		mapfile -t password_temp < <(pass show "$passentry")
		password=${password_temp[0]}

		if [[ ${password} == "#FILE="* ]]; then
			pass_file="${password#*=}"
			mapfile -t password_temp2 < <(pass show "${pass_file}")
			password=${password_temp2[0]}
		fi

		fields=$(printf '%s\n' "${password_temp[@]:1}" |
					 awk '$1 ~ /:$/ || /otpauth:\/\// {$1=$1;print}')

		unset password_temp

		# FIXME: wtf is stuff
		declare -A stuff
		stuff["pass"]=${password}

		if [[ -n $fields ]]; then
			while read -r LINE; do
				unset _id _val
				case "$LINE" in
					"otpauth://"*|"${OTPmethod_field}"*)
						_id="OTP"
						_val=""
						;;
					*)
						_id="${LINE%%: *}"
						_val="${LINE#* }"
						;;
				esac

				[[ -n "$_id" ]] && stuff["${_id}"]=${_val}
			done < <(printf '%s\n' "${fields}")

			if test "${stuff['autotype']+autotype}"; then
				:
			else
				stuff["autotype"]="${USERNAME_field} :tab pass"
			fi
		fi
	fi

	if [[ -z "${stuff["${AUTOTYPE_field}"]}" ]]; then
		if [[ -n $default_autotype ]]; then
			stuff["${AUTOTYPE_field}"]="${default_autotype}"
		fi
	fi
	if [[ -z "${stuff["${USERNAME_field}"]}" ]]; then
		if [[ -n $default_user ]]; then
			if [[ "$default_user" == ":filename" ]]; then
				stuff["${USERNAME_field}"]="$(basename "$passentry")"
			else
				stuff["${USERNAME_field}"]="${default_user}"
			fi
		fi
	fi

	pass_content="$(for key in "${!stuff[@]}"; do printf '%s\n' "${key}: ${stuff[$key]}"; done)"

	# actions based on keypresses
	# The exit code for -kb-custom-X is X+9.
	case "${rofi_exit}" in
		0) typeMenu "$passentry";;
		10) sleep $wait; autopass "$passentry";;
		11) sleep $wait; typeUser;;
		12) sleep $wait; typePass;;
		13) openURL "$passentry" ;;
		14) copyField $USERNAME_field ;;
		15) copyPass;;
		16) viewEntry "$passentry";;
		17) copyField $URL_field ;;
		18) default_do="menu" typeMenu "$passentry";;
		21) sleep $wait; typefield=OTP; typeField "$passentry";;
		23) actionMenu "$passentry";;
		24) copyMenu;;
		27) insertPass;;
		28) generateQrCode "$passentry";;
	esac

	clearUp
}

clearUp () {
	password=''
	unset stuff
	unset password
	unset stuff
}

helpMenu () {
	_rofi -mesg "Hint: All hotkeys are configurable in config file" -p "Help > " <<- EOM
	${autotype}: Autotype
	${type_user}: Type Username
	${type_pass}: Type Password
	${type_otp}: Type OTP
	${qrcode}: Generate and display qrcode
	---
	${copy_name}: Copy Username
	${copy_pass}: Copy Password
	${copy_url}: Copy URL
	${open_url}: Open URL
	${copy_menu}: Copy Custom Field
	---
	${action_menu}: Edit, Move, Delete, Re-generate Submenu
	${show}: Show Password File
	${insert_pass}: Insert new Pass Entry
	${switch}: Switch Pass/Bookmark Mode
	---
	${previous_root}: Switch to previous password store (--root)
	${next_root}: Switch to next password store (--root)
EOM

	assert_status $?

	unset helptext; mainMenu;
}

typeMenu () {
	local passentry="$1"
	if [[ -n $default_do ]]; then
		if [[ $default_do == "menu" ]]; then
			local -a keys=("${!stuff[@]}")
			keys=("${keys[@]/$AUTOTYPE_field}")
			typefield=$({ printf '%s' "${AUTOTYPE_field}" ; printf '%s\n' "${keys[@]}" |
							  sort; } | _rofi -p "Choose Field to type > ")

			assert_status $?

			case "$typefield" in
				'') exit;;
				'pass') sleep $wait; typePass;;
				"${AUTOTYPE_field}") sleep $wait; autopass "$passentry";;
				*) sleep $wait; typeField "$passentry"
			esac

			clearUp

		elif [[ $default_do == "${AUTOTYPE_field}" ]]; then
			sleep $wait; autopass "$passentry"
		else
			${default_do}
		fi
	fi
}

copyMenu () {
	copyfield=$(printf '%s\n' "${!stuff[@]}" | sort |
					_rofi -p "Choose Field to copy > ")

	assert_status $?

	case $copyfield in
		"pass") copyPass ;;
		*) copyField "$copyfield" ;;
	esac

	clearUp
}

# receives current password entry as a parameter
actionMenu () {
	local ret="< Return"
	local move="1 Move Password File"
	local copy="2 Copy Password File"
	local delete="3 Delete Password File"
	local edit="4 Edit Password File"
	local generate="5 Generate New Password"

	actions=("$ret" "---" "$move" "$copy" "$delete" "$edit" "$generate")

	action=$(printf '%s\n' "${actions[@]}" | _rofi -p "Choose Action > ")

	case $action in
		"$move") manageEntry "$1" move ;;
		"$delete") manageEntry "$1" delete ;;
		"$copy") manageEntry "$1" copy ;;
		"$edit") manageEntry "$1" edit ;;
		"$generate") generatePass "$1" ;;
		"$ret") mainMenu ;;
		*) exit ;;
	esac
}

showEntry () {
	local password=$1
	if [[ -z $pass_content ]]; then
		pass_temp=$(pass show "$password")
		password="${pass_temp%%$'\n'*}"
		pass_key_value=$(printf '%s\n' "${pass_temp}" | tail -n+2 | grep ': ')
		declare -A stuff

		while read -r LINE; do
			_id="${LINE%%: *}"
			_val="${LINE#* }"
			stuff["${_id}"]=${_val}
		done < <(printf '%s\n' "${pass_key_value}")

		stuff["pass"]=${password}

		if test "${stuff['autotype']+autotype}"; then
			:
		else
			stuff["autotype"]="${USERNAME_field} :tab pass"
		fi

		pass_content="$(for key in "${!stuff[@]}"; do printf '%s\n' "${key}: ${stuff[$key]}"; done)"
	fi

	bla_content=("< Return" "${pass_content}")
	bla=$(printf '%s\n' "${bla_content[@]}" | _rofi -mesg "Enter: Copy entry to clipboard" -p "> ")
	assert_status $?

	word=$(printf '%s' "$bla" | gawk -F': ' '{print $1}')

	if [[ ${bla} == "< Return" ]]; then
		mainMenu
	else
		if [[ -z $(printf '%s' "${stuff[${word}]}") ]]; then
			printf '%s' "$word" | doClip
		else
			printf '%s' "${stuff[${word}]}" | doClip
		fi

		notify_on &&
			_notify "Copied Password\\nClearing in $clip_clear seconds"

		clearClip &

		exit
	fi

	unset stuff
	unset password
	unset stuff
	exit
}

manageEntry () {
	local passentry="$1"
	if [[ "$2" == "edit" ]]; then
		pass edit "${passentry}"
	elif [[ "$2" == "move" ]]; then
		cd "${root}" || exit
		group_array=(*/)
		group=$(printf '%s\n' "${group_array[@]%/}" | _rofi -p "Choose Group > ")
		assert_status $?

		pass mv "$passentry" "$path"

	elif [[ "$2" == "copy" ]]; then
		cd "${root}" || exit
		group_array=(*/)
		group=$(printf '%s\n' "${group_array[@]%/}" | _rofi -p "Choose Group > ")
		assert_status $?

		message="Copying to same Group. Please enter a name for the new entry"
		new_name="$(listgpg | _rofi -format 'f' -mesg "$message" -p "> ")"
		PASSWORD_STORE_DIR="${root}" pass cp "$passentry" "${group}/${new_name}"

	elif [[ "$2" == "delete" ]]; then
		HELP="Selected entry: ${passentry}"
		ask_content=("Yes" "No")
		ask=$(printf '%s\n' "${ask_content[@]}" | _rofi -mesg "${HELP}" -p "Are You Sure? > ")

		case $ask in
			"Yes") pass rm --force "${passentry}" ;;
			"No") mainMenu ;;
			*) exit ;;
		esac
	fi

	mainMenu
}

edit_pass() {
    [[ $edit_new_pass == "true" ]] && pass edit "${1}"
}

insertPass () {
	url=$(clip_out_clipboard)

	if [[ "${url:0:4}" == "http" ]]; then
		domain_name="$(printf '%s\n' "${url}" | awk -F / '{l=split($3,a,"."); \
			print (a[l-1]=="com"?a[l-2] OFS:X) a[l-1] OFS a[l]}' OFS=".")"
		help_content="Domain: ${domain_name}\nType name, make sure it is unique"
	else
		help_content="Hint: Copy URL to clipboard before calling this menu.
		Type name, make sure it is unique"
	fi

	cd "${root}" || exit

	name="$(listgpg | \
		_rofi -format 'f' -filter "${domain_name}" -mesg "${help_content}" -p "> ")"
	assert_status $?

	user_content=("${default_user2}" "${USER}" "${default_user}")
	user=$(printf '%s\n' "${user_content[@]}" | \
		_rofi -mesg "Chose Username or type" -p "> ")
	assert_status $?

	message="Type Password or hit Enter to generate one"
	pw=$(printf '%s' "Generate" | \
		_rofi -password -p "Password > " -mesg "$message")

	[[ $pw == "Generate" ]] && pw=$(_pwgen "${password_length}")

	clear

	pass_content=("${pw}" "---" "${USERNAME_field}: ${user}")
	[[ $url == http* ]] && pass_content+=("${URL_field}: ${url}")

	local pass_name="$name"

	printf '%s\n' "${pass_content[@]}" |
		pass insert -m "${pass_name}" > /dev/null && edit_pass "${pass_name}"
}

help_msg () {
	cat <<'EOF'
	Usage:
	rofi-pass [command]

	Commands:
	--insert         insert new entry to password store
	--root           set custom root directories (colon separated)
	--bmarks         start in bookmarks mode

	rofi-pass version 1.5.3
EOF
}

get_config_file () {
	configs=(
		"$ROFI_PASS_CONFIG"
		"$config_dir/rofi-pass/config"
		"/etc/rofi-pass.conf"
	)

	# return the first config file with a valid path
	for config in "${configs[@]}"; do
		# '-n' is needed in case ROFI_PASS_CONFIG is not set
		if [[ -n "${config}" && -f "${config}" ]]; then
			printf "%s" "$config"
			return
		fi
	done
}

set_roots () {
	if [[ -n "$2" && "$1" == "--root" ]]; then
		custom_root=true; IFS=: read -r -a roots <<< "$2"
	elif [[ -n $root ]]; then
		custom_root=true; IFS=: read -r -a roots <<< "${root}"
	elif [[ -n ${PASSWORD_STORE_DIR} ]]; then
		roots=("${PASSWORD_STORE_DIR}")
	else
		roots=("$HOME/.password-store")
	fi
	roots_index=0
	roots_length=${#roots[@]}
	export root=${roots[$roots_index]}
	export PASSWORD_STORE_DIR="${root}"
}

main () {
	# load config file
	config_file="$(get_config_file)"
	[[ -n "$config_file" ]] && source "$config_file"

	# check for BROWSER variable, use xdg-open as fallback
	[[ -z $BROWSER ]] && export BROWSER=xdg-open

	# if user has defined his own editor in config file - use it for this script
	[[ -n $EDITOR ]] && export EDITOR=$EDITOR

	set_roots "$@"

	case $1 in
		--insert) insertPass ;;
		--root) mainMenu ;;
		--help) help_msg ;;
		--bmarks) mainMenu --bmarks; ;;
		*) mainMenu ;;
	esac
}

main "$@"
