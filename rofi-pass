#!/usr/bin/env bash

# rofi-pass
# (c) 2015 Rasmus Steinke <rasi@xssn.at>

basecommand="$0"

###############################################################################
#              Config defaults (in case user doesn't copies one)               #
###############################################################################

# permanently set alternative root dir. Use ":" to separate multiple roots
# which can be switched at runtime with shift+left/right
# root=/path/to/root

# Fields to be used
URL_FIELD='url'
USERNAME_FIELD='user'
AUTOTYPE_FIELD='autotype'
OTPMETHOD_FIELD='otp_method'

BACK_OPTION='< back'

## Programs to be used
EDITOR='vim -x' # Editor
BROWSER='xdg-open' # Browser

# delay to be used for :delay keyword
delay=2
# rofi-pass needs to close itself before it can type passwords. Set delay here.
wait=0.2
# delay between keypresses when typing (in ms)
type_delay=12

# Clipboard settings
# Possible options: primary, clipboard, both
clip=primary
# Seconds before clearing pass from clipboard
clip_clear=45

## Options for generating new password entries
# open new password entries in editor
edit_new_pass="true"
# set to ':filename' for user field to be set to password file name
default_user="${ROFI_PASS_DEFAULT_USER-$(whoami)}"
default_user2=john_doe
password_length=12

## Misc settings

default_autotype="user :tab pass"
auto_enter='false'
notify='false'

# default shortcuts
autotype="Alt+1"
type_user="Alt+2"
type_pass="Alt+3"
open_url="Alt+4"
type_otp="Alt+5"
copy_name="Alt+u"
copy_url="Alt+l"
copy_pass="Alt+p"
show="Alt+o"
copy_menu="Alt+c"
action_menu="Alt+a"
type_menu="Alt+t"
help="Alt+h"
switch="Alt+x"
insert_pass="Alt+n"
qrcode="Alt+q"
previous_root="Shift+Left"
next_root="Shift+Right"

# --- User redefinable functions ---

_rofi () { rofi -no-auto-select -i -dmenu "$@"; }

_notify() { notify-send -e "rofi-pass" "$1"; }

_image_viewer () { feh - ; }

_pwgen () { pwgen -y "$@"; }


###############################################################################
#                               Action functions                              #
###############################################################################

mainMenu () {
	local passentry

	args=(
		-kb-custom-1 "${autotype}"
		-kb-custom-2 "${type_user}"
		-kb-custom-3 "${type_pass}"
		-kb-custom-4 "${open_url}"
		-kb-custom-5 "${copy_name}"
		-kb-custom-6 "${copy_pass}"
		-kb-custom-7 "${show}"
		-kb-custom-8 "${copy_url}"
		-kb-custom-9 "${type_menu}"
		-kb-custom-10 "${previous_root}"
		-kb-custom-11 "${next_root}"
		-kb-custom-12 "${type_otp}"
		-kb-custom-14 "${action_menu}"
		-kb-custom-15 "${copy_menu}"
		-kb-custom-16 "${help}"
		-kb-custom-17 "${switch}"
		-kb-custom-18 "${insert_pass}"
		-kb-custom-19 "${qrcode}"

		# These keyboard shortcut options are needed, because
		# Shift+<Left|Right> are otherwise taken by rofi.
		-kb-mode-previous ""
		-kb-mode-next ""
		-p "> "
	)

	if [[ ${#roots[@]} -gt "1" || $custom_root == "true" ]]; then
		args+=(-mesg "PW Store: ${root}")
	fi

	passentry="$(list_passwords 2>/dev/null | _rofi "${args[@]}")"

	rofi_exit=$?

	# Actions based on exit code, which do not need the entry.
	# The exit code for -kb-custom-X is X+9.
	case $rofi_exit in
		1) exit ;;
		19)
			roots_index=$(( (roots_index-1+roots_length) % roots_length))
			root=${roots[$roots_index]}
			mainMenu
			return
			;;
		20)
			roots_index=$(( (roots_index+1) % roots_length))
			root=${roots[$roots_index]}
			mainMenu
			return
			;;
		25) helpMenu; return;;
		26) ${basecommand} --bmarks; return ;;
	esac

	# get an array of password file fields like url: user: and custom ones
	local -a password_temp
	mapfile -t password_temp < <(pass show "$passentry")
	password=${password_temp[0]}

	fields=$(printf '%s\n' "${password_temp[@]:1}" |
				 awk '$1 ~ /:$/ || /otpauth:\/\// {$1=$1;print}')

	unset password_temp

	# FIXME: wtf is stuff
	declare -A stuff
	stuff["pass"]=${password}

	if [[ -n $fields ]]; then
		while read -r LINE; do
			unset _id _val
			case "$LINE" in
				"otpauth://"*|"${OTPMETHOD_FIELD}"*)
					_id="OTP"
					_val=""
					;;
				*)
					_id="${LINE%%: *}"
					_val="${LINE#* }"
					;;
			esac

			[[ -n "$_id" ]] && stuff["${_id}"]=${_val}
		done < <(printf '%s\n' "${fields}")

		if test "${stuff['autotype']+autotype}"; then
			:
		else
			stuff["autotype"]="${USERNAME_FIELD} :tab pass"
		fi
	fi

	if [[ -z "${stuff["${USERNAME_FIELD}"]}" ]]; then
		if [[ -n $default_user ]]; then
			if [[ "$default_user" == ":filename" ]]; then
				stuff["${USERNAME_FIELD}"]="$(basename "$passentry")"
			else
				stuff["${USERNAME_FIELD}"]="${default_user}"
			fi
		fi
	fi

	# actions based on keypresses
	# The exit code for -kb-custom-X is X+9.
	case "${rofi_exit}" in
		0 | 18) type "$passentry" 'menu' ;;
		10) type "$passentry" "$AUTOTYPE_FIELD" ;;
		11) type "$passentry" "$USERNAME_FIELD" ;;
		12) type "$passentry" 'pass'  ;;
		13) openURL "$passentry" ;;
		14) copy $USERNAME_FIELD ;;
		15) copy 'pass' ;;
		16)
			local -a lines
			for key in "${!stuff[@]}"; do lines+=("${key}: ${stuff[$key]}"); done
			showEntry "$(printf '%s\n' "${lines[@]}")"
			;;
		17) copy $URL_FIELD ;;
		21) type "$passentry" 'OTP' ;;
		23) actionMenu "$passentry";;
		24) copy 'menu' ;;
		27) insertPass;;
		28) generateQrCode "$passentry";;
	esac

	clearUp
}

# FIXME: when done with removing global state, rewrite this func to subshell
# func() () so the inner vars remain within this subshell
type() {
	local passentry="$1"
	local field="$2"

	[[ -z "${stuff["${AUTOTYPE_FIELD}"]}" && -n $default_autotype ]] &&
		stuff["${AUTOTYPE_FIELD}"]="${default_autotype}"

	do_type() { wtype -d ${type_delay} - ; }

	# local autopass
	autopass () {
		do_press_key() {
			wtype -P "$1" -p "$1"
		}

		for word in ${stuff["$AUTOTYPE_FIELD"]}; do
			case "$word" in
				":tab") do_press_key Tab ;;
				":space") do_press_key space ;;
				":delay") sleep "${delay}" ;;
				":enter") do_press_key Return ;;
				":otp") printf '%s' "$(generateOTP "$passentry")" | do_type ;;
				"pass") printf '%s' "${password}" | do_type ;;
				"path")
					printf '%s' "${passentry}" | rev | cut -d'/' -f1 | rev | do_type
					;;
				*) printf '%s' "${stuff[${word}]}" | do_type ;;
			esac
		done

		[[ ${auto_enter} == "true" ]] && do_press_key Return
	}

	sleep $wait

	case "$field" in
		# doubt anyone will ever have 'menu' field in their pass file
		"menu")
			local sorted_fields=()
			mapfile -t sorted_fields < <(get_sorted_fields)
			sorted_fields+=("${AUTOTYPE_FIELD}")

			field=$(printf '%s\n' "${sorted_fields[@]}" |
						_rofi -theme-str "$placeholder")
			assert_status $?

			type "$passentry" "$field"
			;;
		"$USERNAME_FIELD") printf '%s' "${stuff[${USERNAME_FIELD}]}" | do_type ;;
		pass) printf '%s' "${password}" | do_type ;;
		"OTP") printf '%s' "$(generateOTP "$passentry")" | do_type ;;
		"$AUTOTYPE_FIELD") autopass ;;
		*) printf '%s' "${stuff[${field}]}" | do_type ;;
	esac

	# TODO: figure out better notifications coverage
	# notify_on || [[ "${stuff[notify]}" == "true" ]] &&
	# 	_notify "finished typing password";

	clearUp
}

generateQrCode() {
	local passentry="$1"

	has_qrencode() { command -v qrencode >/dev/null 2>&1; }

	if ! has_qrencode; then
		printf '%s\n' "qrencode not found" | _rofi
		assert_status $?
		"${basecommand}"
	fi

	# FIXME: display qrcode in rofi right away
	pass "$passentry" | head -n 1 | qrencode -d 300 -v 8 -l H -o - |
		_image_viewer

	if [ $? -eq 1 ]; then
		printf '%s\n' "" |
			_rofi -mesg "Image viewer not defined or cannot read from pipe"
		assert_status $?
		"${basecommand}"
	fi
	clearUp
}

openURL () {
	local passentry="$1"
	url=$(pass "$passentry" | grep "${URL_FIELD}: " |
			  gawk '{sub(/:/,"")}{print $2}1' | head -1)
	[ -z "$url" ] && exit
	$BROWSER "$url"

	clearUp
}

generateOTP () {
	local passentry="$1"

	# First, we check if there is a non-conventional OTP command in the pass file
	_check_otp_cmd() {
		pass "$passentry" | grep -q "${OTPMETHOD_FIELD}: "
	}

	if _check_otp_cmd; then
		# We execute the commands after otp_method: AS-IS
		bash -c "$(_check_otp_cmd)"
	else
		# If there is no method defined, fallback to pass-otp
		pass otp "$passentry"
	fi

	clearUp
}

copy() {
	local field="$1"

	doClip () {
		case "$clip" in
			"primary") clip_in_primary ;;
			"clipboard") clip_in_clipboard ;;
			"both") clip_in_primary; wl-paste -p | clip_in_clipboard;;
		esac
	}

	clearClip() {
		sleep $clip_clear
		printf '%s' "" | clip_in_primary
		printf '%s' "" | clip_in_clipboard
		notify_on && _notify "Clipboard cleared"
	}

	case $field in
		# i doubt anyone will have 'menu' field in their password file
		menu)
			local sorted_fields=()
			mapfile -t sorted_fields < <(get_sorted_fields)
			placeholder=$(wrap_placeholder "Field to copy")
			field=$(printf '%s\n' "${sorted_fields[@]}" | sort |
							_rofi -theme-str "$placeholder")

			assert_status $?

			copy "$field"
		;;
		"pass")
			printf '%s' "$password" | doClip
			clearClip &
			;;
		*) printf '%s' "${stuff[$field]}" | doClip ;;
	esac

	# TODO:
	# notify_on &&
	# 	_notify "Copied Password\\nClearing in $clip_clear seconds"

	# REVIEW: maybe always clear clip?
	# clearClip &

	clearUp
}

# receives current password entry as a parameter
actionMenu () {
	local move="Move"
	local copy="Copy"
	local delete="Delete"
	local edit="Edit"
	local generate="Generate new"

	actions=("$move" "$copy" "$delete" "$edit" "$generate" "$BACK_OPTION")

	placeholder=$(wrap_placeholder "Choose action")
	action=$(printf '%s\n' "${actions[@]}" | _rofi -theme-str "$placeholder")

	case $action in
		"$move") manageEntry "$1" move ;;
		"$delete") manageEntry "$1" delete ;;
		"$copy") manageEntry "$1" copy ;;
		"$edit") manageEntry "$1" edit ;;
		"$generate") generatePass "$1" ;;
		"$BACK_OPTION") mainMenu ;;
		*) exit ;;
	esac
}

manageEntry () {
	local passentry="$1"

	cd "${root}" || exit

	if [[ "$2" == "edit" ]]; then
		pass edit "${passentry}"
	elif [[ "$2" == "move" ]]; then
		placeholder=$(wrap_placeholder "New path for $passentry")
		path=$(list_passwords 2>/dev/null | _rofi -theme-str "$placeholder")
		assert_status $?

		pass mv "$passentry" "$path"

	elif [[ "$2" == "copy" ]]; then
		placeholder=$(wrap_placeholder "Path for $passentry copy")
		path=$(list_passwords 2>/dev/null | _rofi -theme-str "$placeholder")
		assert_status $?

		pass cp "$passentry" "$path"

	elif [[ "$2" == "delete" ]]; then
		HELP="Selected entry: ${passentry}"
		ask_content=("Yes" "No")
		placeholder=$(wrap_placeholder "Are You Sure? > ")
		ask=$(printf '%s\n' "${ask_content[@]}" |
				  _rofi -mesg "${HELP}" -theme-str "$placeholder")

		case $ask in
			"Yes") pass rm --force "${passentry}" ;;
			"No") mainMenu ;;
			*) exit ;;
		esac
	fi

	# TODO: add notification here

	mainMenu
}

generatePass () {
	local passentry="$1"
	askmenu_content=("yes" "no")
	placeholder=$(wrap_placeholder "Generate new password for ${passentry}?")
	generatep=$(printf '%s\n' "${askmenu_content[@]}" |
					 _rofi -theme-str "$placeholder" )

	assert_status $?

	case $generatep in
		yes) true ;;
		no) actionMenu "$1" ;;
	esac

	symbols_content=("yes" "no" "cancel")
	placeholder=$(wrap_placeholder "Use symbols?")
	use_symbols=$(printf '%s\n' "${symbols_content[@]}" | _rofi -theme-str "$placeholder")
	assert_status $?

	case $use_symbols in
		no) symbols="-n" ;;
		cancel) mainMenu ;;
	esac

	placeholder=$(wrap_placeholder "Enter password length (Default: ${password_length})")
	length=$(printf '%s' "" | _rofi -theme-str "$placeholder")
	assert_status $?

	[ -z "$length" ] && length="$password_length"

	# REVIEW: prompt for -c flag?
	# don't quote symbols
	pass generate $symbols -c -i "$passentry" "$length" > /dev/null
}

showEntry () {
	local content="$1"

	content=("$BACK_OPTION" "${content}")
	placeholder=$(wrap_placeholder "Enter: copy entry to clipboard")
	selection=$(printf '%s\n' "${content[@]}" | _rofi -theme-str "$placeholder" -p "> ")
	assert_status $?

	field=$(printf '%s' "$selection" | cut -d':' -f 1)

	case $field in
		"$BACK_OPTION") mainMenu ;;
		*) copy "$field" ;;
	esac

	exit
}

insertPass () {
	url=$(wl-paste)

	if [[ "${url:0:4}" == "http" ]]; then
		domain_name="$(printf '%s\n' "${url}" | awk -F / '{l=split($3,a,"."); \
			print (a[l-1]=="com"?a[l-2] OFS:X) a[l-1] OFS a[l]}' OFS=".")"
		help_content="Domain: ${domain_name}"
	else
		help_content="Hint: Copy URL to clipboard before calling this menu."
	fi

	cd "${root}" || exit

	placeholder=$(wrap_placeholder "Enter name, must be unique ... ")
	name=$(list_passwords | _rofi -format 'f' -filter "${domain_name}" \
		-theme-str "$placeholder" -mesg "${help_content}" -p "> ")
	assert_status $?

	user_content=("${default_user2}" "${USER}" "${default_user}")
	placeholder=$(wrap_placeholder "Enter username")
	user=$(printf '%s\n' "${user_content[@]}" | \
		_rofi -theme-str "$placeholder" -p "> ")
	assert_status $?

	message="Type Password or hit Enter to generate one"
	placeholder=$(wrap_placeholder "Password")
	pw=$(printf '%s' "Generate" | \
		_rofi -password -theme-str "$placeholder" -mesg "$message")

	[[ $pw == "Generate" ]] && pw=$(_pwgen "${password_length}")

	clear

	pass_content=("${pw}" "---" "${USERNAME_FIELD}: ${user}")
	[[ $url == http* ]] && pass_content+=("${URL_FIELD}: ${url}")

	local pass_name="$name"

	printf '%s\n' "${pass_content[@]}" |
		pass insert -m "${pass_name}" > /dev/null && \
			[[ $edit_new_pass == "true" ]] && pass edit "${pass_name}"
}

helpMenu () {
	_rofi -mesg "Hint: All hotkeys are configurable in config file" -p "Help > " <<- EOM
	${autotype}: Autotype
	${type_user}: Type Username
	${type_pass}: Type Password
	${type_otp}: Type OTP
	${qrcode}: Generate and display qrcode
	---
	${copy_name}: Copy Username
	${copy_pass}: Copy Password
	${copy_url}: Copy URL
	${open_url}: Open URL
	${copy_menu}: Copy Custom Field
	---
	${action_menu}: Edit, Move, Delete, Re-generate Submenu
	${show}: Show Password File
	${insert_pass}: Insert new Pass Entry
	${switch}: Switch Pass/Bookmark Mode
	---
	${previous_root}: Switch to previous password store (--root)
	${next_root}: Switch to next password store (--root)
EOM

	assert_status $?

	unset helptext; mainMenu;
}


###############################################################################
#                               Helper functions                              #
###############################################################################

clip_in_primary() { wl-copy -p; }

clip_in_clipboard() { wl-copy; }

notify_on() {
	if [[ $notify == "true" ]]; then
		return 0
	else
		return 1
	fi
}

assert_status() { [ "$1" -eq 1 ] && exit; }

# get all password files and output as newline-delimited text
list_passwords() {
	cd "${root}" || exit
	mapfile -d '' pw_list < <(find -L . -name '*.gpg' -print0)
	pw_list=("${pw_list[@]#./}")
	printf '%s\n' "${pw_list[@]%.gpg}" | sort -n
}

wrap_placeholder() { echo "#entry { placeholder: \"$1\"; }"; }

# FIXME: get rid of this one
clearUp () {
	password=''
	unset stuff
	unset password
}

# Returns sorted keys for current password entry with 'autotype' key removed.
# Fields like 'user', 'url', etc
get_sorted_fields() {
	local -a keys=("${!stuff[@]}")
	# remove autotype field from keys array
	keys=("${keys[@]/$AUTOTYPE_FIELD}")

	placeholder=$(wrap_placeholder "Field to autotype")

	# grep is needed cuz after 'autotype' field gets cleared from the
	# array above, indecies do not update and we get an empty element.
	# So it's needed to filter out empty strings
	printf '%s\n' "${keys[@]}" | sort | grep -v "^$"
}

help_msg () {
	cat <<'EOF'
	Usage:
	rofi-pass [command]

	Commands:
	--insert         insert new entry to password store
	--root           set custom root directories (colon separated)
	--bmarks         start in bookmarks mode
EOF
}


###############################################################################
#                             Main function logic                             #
###############################################################################

# sources the first config file with a valid path
load_config () {
	local config_dir=${XDG_CONFIG_HOME:-$HOME/.config}
	local -a configs=(
		"$ROFI_PASS_CONFIG"
		"$config_dir/rofi-pass/config"
		"/etc/rofi-pass.conf"
	)

	for config in "${configs[@]}"; do
		# '-n' is needed in case ROFI_PASS_CONFIG is not set
		if [[ -n "${config}" && -f "${config}" ]]; then
			source "$config"
			return
		fi
	done
}

# FIXME: either don't globalise or make the roots logic more clear
set_roots () {
	if [[ -n "$2" && "$1" == "--root" ]]; then
		custom_root=true; IFS=: read -r -a roots <<< "$2"
	elif [[ -n ${PASSWORD_STORE_DIR} ]]; then
		roots=("${PASSWORD_STORE_DIR}")
	else
		roots=("$HOME/.password-store")
	fi
	roots_index=0
	roots_length=${#roots[@]}
	export root=${roots[$roots_index]}
	export PASSWORD_STORE_DIR="${root}"
}

main () {
	load_config

	# check for BROWSER variable, use xdg-open as fallback
	[[ -z $BROWSER ]] && export BROWSER=xdg-open

	# if user has defined his own editor in config file - use it for this script
	[[ -n $EDITOR ]] && export EDITOR=$EDITOR

	set_roots "$@"

	# TODO: see which flags make sence to be added here instead of deprecated
	# 'default_do'
	# menu, copy menu, type menu, showEntry, actionMenu, openUrl
	case $1 in
		--insert) insertPass ;;
		--help) help_msg ;;
		--bmarks)
			placeholder=$(wrap_placeholder "Bookmarks Mode. ${switch} to switch")
			passentry="$(list_passwords 2>/dev/null | \
				_rofi -kb-custom-10 "${switch}" -theme-str "$placeholder")"

			case $? in
				0) openURL "$passentry" ;;
				19) ${basecommand} ;;
				*) exit ;;
			esac
			;;
		*) mainMenu ;;
	esac
}

main "$@"
