#!/usr/bin/env bash

# rofi-pass
# (c) 2015 Rasmus Steinke <rasi@xssn.at>
basecommand="$0"

config_dir=${XDG_CONFIG_HOME:-$HOME/.config}

# --- Config defaults (in case user doesn't copies one) ---

# permanently set alternative root dir. Use ":" to separate multiple roots
# which can be switched at runtime with shift+left/right
# root=/path/to/root

# Fields to be used
URL_FIELD='url'
USERNAME_FIELD='user'
AUTOTYPE_FIELD='autotype'
OTPMETHOD_FIELD='otp_method'

BACK_OPTION='< back'

## Programs to be used
EDITOR='vim -x' # Editor
BROWSER='xdg-open' # Browser

# delay to be used for :delay keyword
delay=2
# rofi-pass needs to close itself before it can type passwords. Set delay here.
wait=0.2
# delay between keypresses when typing (in ms)
type_delay=12

# Clipboard settings
# Possible options: primary, clipboard, both
clip=primary
# Seconds before clearing pass from clipboard
clip_clear=45

## Options for generating new password entries
# open new password entries in editor
edit_new_pass="true"
default_user="${ROFI_PASS_DEFAULT_USER-$(whoami)}"
default_user2=john_doe
password_length=12

## Misc settings

default_autotype="user :tab pass"
auto_enter='false'
notify='false'

# default shortcuts
autotype="Alt+1"
type_user="Alt+2"
type_pass="Alt+3"
open_url="Alt+4"
type_otp="Alt+5"
copy_name="Alt+u"
copy_url="Alt+l"
copy_pass="Alt+p"
show="Alt+o"
copy_menu="Alt+c"
action_menu="Alt+a"
type_menu="Alt+t"
help="Alt+h"
switch="Alt+x"
insert_pass="Alt+n"
qrcode="Alt+q"
previous_root="Shift+Left"
next_root="Shift+Right"

# --- END Config defaults ---

_rofi () {
	rofi -no-auto-select -i -dmenu "$@"
}

clip_in_primary() {
	wl-copy -p
}

clip_in_clipboard() {
	wl-copy
}

do_type() {
	wtype -d ${type_delay} -
}

notify_on() {
	if [[ $notify == "true" ]]; then
		return 0
	else
		return 1
	fi
}

# wrapper for notify-send, can be redefined in config
_notify() {
	notify-send -e "rofi-pass" "$1"
}

has_qrencode() {
	command -v qrencode >/dev/null 2>&1
}

assert_status() {
	[ "$1" -eq 1 ] && exit
}

listgpg () {
	mapfile -d '' pw_list < <(find -L . -name '*.gpg' -print0)
	pw_list=("${pw_list[@]#./}")
	printf '%s\n' "${pw_list[@]}" | sort -n
}

# get all password files and output as newline-delimited text
list_passwords() {
	cd "${root}" || exit
	mapfile -t pw_list < <(listgpg)
	printf '%s\n' "${pw_list[@]%.gpg}" | sort -n
}

doClip () {
	case "$clip" in
		"primary") clip_in_primary ;;
		"clipboard") clip_in_clipboard ;;
		"both") clip_in_primary; wl-paste -p | clip_in_clipboard;;
	esac
}

# FIXME: when done with removing global state, rewrite this func to subshell
# func() () so the inner vars remain within this subshell
type() {
	local passentry="$1"
	local field="$2"

	[[ -z "${stuff["${AUTOTYPE_FIELD}"]}" && -n $default_autotype ]] &&
		stuff["${AUTOTYPE_FIELD}"]="${default_autotype}"

	# local autopass
	autopass () {
		do_press_key() {
			wtype -P "$1" -p "$1"
		}

		for word in ${stuff["$AUTOTYPE_FIELD"]}; do
			case "$word" in
				":tab") do_press_key Tab ;;
				":space") do_press_key space ;;
				":delay") sleep "${delay}" ;;
				":enter") do_press_key Return ;;
				":otp") printf '%s' "$(generateOTP "$passentry")" | do_type ;;
				"pass") printf '%s' "${password}" | do_type ;;
				"path")
					printf '%s' "${passentry}" | rev | cut -d'/' -f1 | rev | do_type
					;;
				*) printf '%s' "${stuff[${word}]}" | do_type ;;
			esac
		done

		[[ ${auto_enter} == "true" ]] && do_press_key Return
	}

	sleep $wait

	case "$field" in
		# doubt anyone will ever have 'menu' field in their pass file
		"menu")
			local sorted_fields=()
			mapfile -t sorted_fields < <(get_sorted_fields)
			sorted_fields+=("${AUTOTYPE_FIELD}")

			field=$(printf '%s\n' "${sorted_fields[@]}" |
						_rofi -theme-str "$placeholder")
			assert_status $?

			type "$passentry" "$field"
			;;
		"$USERNAME_FIELD") printf '%s' "${stuff[${USERNAME_FIELD}]}" | do_type ;;
		pass) printf '%s' "${password}" | do_type ;;
		"OTP") printf '%s' "$(generateOTP "$passentry")" | do_type ;;
		"$AUTOTYPE_FIELD") autopass ;;
		*) printf '%s' "${stuff[${field}]}" | do_type ;;
	esac

	# TODO: figure out better notifications coverage
	# notify_on || [[ "${stuff[notify]}" == "true" ]] &&
	# 	_notify "finished typing password";

	clearUp
}

_image_viewer () {
	feh -
}

generateQrCode() {
	local passentry="$1"

	if ! has_qrencode; then
		printf '%s\n' "qrencode not found" | _rofi
		assert_status $?
		"${basecommand}"
	fi

	# FIXME: display qrcode in rofi right away
	pass "$passentry" | head -n 1 | qrencode -d 300 -v 8 -l H -o - |
		_image_viewer

	if [ $? -eq 1 ]; then
		printf '%s\n' "" |
			_rofi -mesg "Image viewer not defined or cannot read from pipe"
		assert_status $?
		"${basecommand}"
	fi
	clearUp
}

openURL () {
	local passentry="$1"
	url=$(pass "$passentry" | grep "${URL_FIELD}: " |
			  gawk '{sub(/:/,"")}{print $2}1' | head -1)
	[ -z "$url" ] && exit
	$BROWSER "$url"

	clearUp
}

generateOTP () {
	local passentry="$1"

	# First, we check if there is a non-conventional OTP command in the pass file
	_check_otp_cmd() {
		pass "$passentry" | grep -q "${OTPmethod_field}: "
	}

	if _check_otp_cmd; then
		# We execute the commands after otp_method: AS-IS
		bash -c "$(_check_otp_cmd)"
	else
		# If there is no method defined, fallback to pass-otp
		pass otp "$passentry"
	fi

	clearUp
}

clearClip() {
	sleep $clip_clear
	printf '%s' "" | clip_in_primary
	printf '%s' "" | clip_in_clipboard
	notify_on && _notify "Clipboard cleared"
}

wrap_placeholder() {
	echo "#entry { placeholder: \"$1\"; }"
}

mainMenu () {
	local passentry
	if [[ $1 == "--bmarks" ]]; then
		placeholder=$(wrap_placeholder "Bookmarks Mode. ${switch} to switch")
		passentry="$(list_passwords 2>/dev/null | \
			_rofi -kb-custom-10 "${switch}" -theme-str "$placeholder")"

		case $? in
			1) exit ;;
			19) ${basecommand} ;;
			0) openURL "$passentry" ;;
		esac
	else
		unset passentry

		args=(
			-kb-custom-1 "${autotype}"
			-kb-custom-2 "${type_user}"
			-kb-custom-3 "${type_pass}"
			-kb-custom-4 "${open_url}"
			-kb-custom-5 "${copy_name}"
			-kb-custom-6 "${copy_pass}"
			-kb-custom-7 "${show}"
			-kb-custom-8 "${copy_url}"
			-kb-custom-9 "${type_menu}"
			-kb-custom-10 "${previous_root}"
			-kb-custom-11 "${next_root}"
			-kb-custom-12 "${type_otp}"
			-kb-custom-14 "${action_menu}"
			-kb-custom-15 "${copy_menu}"
			-kb-custom-16 "${help}"
			-kb-custom-17 "${switch}"
			-kb-custom-18 "${insert_pass}"
			-kb-custom-19 "${qrcode}"

			# These keyboard shortcut options are needed, because
			# Shift+<Left|Right> are otherwise taken by rofi.
			-kb-mode-previous ""
			-kb-mode-next ""
			-p "> "
		)

		if [[ ${#roots[@]} -gt "1" || $custom_root == "true" ]]; then
			args+=(-mesg "PW Store: ${root}")
		fi

		passentry="$(list_passwords 2>/dev/null | _rofi "${args[@]}")"

		rofi_exit=$?

		# Actions based on exit code, which do not need the entry.
		# The exit code for -kb-custom-X is X+9.
		case $rofi_exit in
			1) exit ;;
			19)
				roots_index=$(( (roots_index-1+roots_length) % roots_length))
				root=${roots[$roots_index]}
				mainMenu
				return
				;;
			20)
				roots_index=$(( (roots_index+1) % roots_length))
				root=${roots[$roots_index]}
				mainMenu
				return
				;;
			25) helpMenu; return;;
			26) ${basecommand} --bmarks; return;;
		esac

		# get an array of password file fields like url: user: and custom ones
		local -a password_temp
		mapfile -t password_temp < <(pass show "$passentry")
		password=${password_temp[0]}

		if [[ ${password} == "#FILE="* ]]; then
			pass_file="${password#*=}"
			mapfile -t password_temp2 < <(pass show "${pass_file}")
			password=${password_temp2[0]}
		fi

		fields=$(printf '%s\n' "${password_temp[@]:1}" |
					 awk '$1 ~ /:$/ || /otpauth:\/\// {$1=$1;print}')

		unset password_temp

		# FIXME: wtf is stuff
		declare -A stuff
		stuff["pass"]=${password}

		if [[ -n $fields ]]; then
			while read -r LINE; do
				unset _id _val
				case "$LINE" in
					"otpauth://"*|"${OTPmethod_field}"*)
						_id="OTP"
						_val=""
						;;
					*)
						_id="${LINE%%: *}"
						_val="${LINE#* }"
						;;
				esac

				[[ -n "$_id" ]] && stuff["${_id}"]=${_val}
			done < <(printf '%s\n' "${fields}")

			if test "${stuff['autotype']+autotype}"; then
				:
			else
				stuff["autotype"]="${USERNAME_FIELD} :tab pass"
			fi
		fi
	fi

	if [[ -z "${stuff["${USERNAME_FIELD}"]}" ]]; then
		if [[ -n $default_user ]]; then
			if [[ "$default_user" == ":filename" ]]; then
				stuff["${USERNAME_FIELD}"]="$(basename "$passentry")"
			else
				stuff["${USERNAME_FIELD}"]="${default_user}"
			fi
		fi
	fi

	pass_content="$(for key in "${!stuff[@]}"; do printf '%s\n' "${key}: ${stuff[$key]}"; done)"

	# actions based on keypresses
	# The exit code for -kb-custom-X is X+9.
	case "${rofi_exit}" in
		0 | 18) type "$passentry" 'menu' ;;
		10) type "$passentry" "$AUTOTYPE_FIELD" ;;
		11) type "$passentry" "$USERNAME_FIELD" ;;
		12) type "$passentry" 'pass'  ;;
		13) openURL "$passentry" ;;
		14) copy $USERNAME_FIELD ;;
		15) copy 'pass' ;;
		16) showEntry ;;
		17) copy $URL_FIELD ;;
		21) type "$passentry" 'OTP' ;;
		23) actionMenu "$passentry";;
		24) copy 'menu' ;;
		27) insertPass;;
		28) generateQrCode "$passentry";;
	esac

	clearUp
}

clearUp () {
	password=''
	unset stuff
	unset password
	unset stuff
}

helpMenu () {
	_rofi -mesg "Hint: All hotkeys are configurable in config file" -p "Help > " <<- EOM
	${autotype}: Autotype
	${type_user}: Type Username
	${type_pass}: Type Password
	${type_otp}: Type OTP
	${qrcode}: Generate and display qrcode
	---
	${copy_name}: Copy Username
	${copy_pass}: Copy Password
	${copy_url}: Copy URL
	${open_url}: Open URL
	${copy_menu}: Copy Custom Field
	---
	${action_menu}: Edit, Move, Delete, Re-generate Submenu
	${show}: Show Password File
	${insert_pass}: Insert new Pass Entry
	${switch}: Switch Pass/Bookmark Mode
	---
	${previous_root}: Switch to previous password store (--root)
	${next_root}: Switch to next password store (--root)
EOM

	assert_status $?

	unset helptext; mainMenu;
}

# Returns sorted keys for current password entry with 'autotype' key removed.
# Fields like 'user', 'url', etc
get_sorted_fields() {
	local -a keys=("${!stuff[@]}")
	# remove autotype field from keys array
	keys=("${keys[@]/$AUTOTYPE_FIELD}")

	placeholder=$(wrap_placeholder "Field to autotype")

	# grep is needed cuz after 'autotype' field gets cleared from the
	# array above, indecies do not update and we get an empty element.
	# So it's needed to filter out empty strings
	printf '%s\n' "${keys[@]}" | sort | grep -v "^$"
}

copy() {
	local field="$1"
	case $field in
		# i doubt anyone will have 'menu' field in their password file
		menu)
			local sorted_fields=()
			mapfile -t sorted_fields < <(get_sorted_fields)
			placeholder=$(wrap_placeholder "Field to copy")
			field=$(printf '%s\n' "${sorted_fields[@]}" | sort |
							_rofi -theme-str "$placeholder")

			assert_status $?

			copy "$field"
		;;
		"pass")
			printf '%s' "$password" | doClip
			clearClip &
			;;
		*) printf '%s' "${stuff[$field]}" | doClip ;;
	esac

	# TODO:
	# notify_on &&
	# 	_notify "Copied Password\\nClearing in $clip_clear seconds"

	clearUp
}

# receives current password entry as a parameter
actionMenu () {
	local move="Move"
	local copy="Copy"
	local delete="Delete"
	local edit="Edit"
	local generate="Generate new"
	local ret="Back"

	actions=("$move" "$copy" "$delete" "$edit" "$generate" "$ret")

	placeholder=$(wrap_placeholder "Choose action")
	action=$(printf '%s\n' "${actions[@]}" | _rofi -theme-str "$placeholder")

	case $action in
		"$move") manageEntry "$1" move ;;
		"$delete") manageEntry "$1" delete ;;
		"$copy") manageEntry "$1" copy ;;
		"$edit") manageEntry "$1" edit ;;
		"$generate") generatePass "$1" ;;
		"$ret") mainMenu ;;
		*) exit ;;
	esac
}

generatePass () {
	local passentry="$1"
	askmenu_content=("Yes" "No")
	placeholder=$(wrap_placeholder "Generate new password for ${passentry}?")
	askGenMenu=$(printf '%s\n' "${askmenu_content[@]}" |
					 _rofi -theme-str "$placeholder" )

	assert_status $?

	if [[ $askGenMenu == "Yes" ]]; then
		true
	elif [[ $askGenMenu == "No" ]]; then
		actionMenu "$1"
	fi

	symbols_content=("yes" "no" "cancel")
	placeholder=$(wrap_placeholder "Use symbols?")
	symbols=$(printf '%s\n' "${symbols_content[@]}" | _rofi -theme-str "$placeholder")
	assert_status $?

	case $symbols in
		yes) symbols="" ;;
		no) symbols="-n" ;;
		cancel) mainMenu ;;
	esac

	placeholder=$(wrap_placeholder "Enter password length (Default: ${password_length})")
	length=$(printf '%s' "" | _rofi -theme-str "$placeholder")
	assert_status $?

	[ -z "$length" ] && length="$password_length"

	pass generate "${symbols}" -i "$passentry" "${length}" > /dev/null;
}

showEntry () {
	local password=$1

	if [[ -z $pass_content ]]; then
		pass_temp=$(pass show "$password")
		password="${pass_temp%%$'\n'*}"
		pass_key_value=$(printf '%s\n' "${pass_temp}" | tail -n+2 | grep ': ')
		declare -A stuff

		while read -r LINE; do
			_id="${LINE%%: *}"
			_val="${LINE#* }"
			stuff["${_id}"]=${_val}
		done < <(printf '%s\n' "${pass_key_value}")

		stuff["pass"]=${password}

		if test "${stuff['autotype']+autotype}"; then
			:
		else
			stuff["autotype"]="${USERNAME_FIELD} :tab pass"
		fi

		pass_content="$(for key in "${!stuff[@]}"; do printf '%s\n' "${key}: ${stuff[$key]}"; done)"
	fi

	bla_content=("< Return" "${pass_content}")
	placeholder=$(wrap_placeholder "Enter: copy entry to clipboard")
	bla=$(printf '%s\n' "${bla_content[@]}" | _rofi -theme-str "$placeholder" -p "> ")
	assert_status $?

	word=$(printf '%s' "$bla" | gawk -F': ' '{print $1}')

	if [[ ${bla} == "< Return" ]]; then
		mainMenu
	else
		if [[ -z $(printf '%s' "${stuff[${word}]}") ]]; then
			printf '%s' "$word" | doClip
		else
			printf '%s' "${stuff[${word}]}" | doClip
		fi

		notify_on &&
			_notify "Copied Password\\nClearing in $clip_clear seconds"

		clearClip &

		exit
	fi

	unset stuff
	unset password
	exit
}

manageEntry () {
	local passentry="$1"

	cd "${root}" || exit

	if [[ "$2" == "edit" ]]; then
		pass edit "${passentry}"
	elif [[ "$2" == "move" ]]; then
		placeholder=$(wrap_placeholder "New path for $passentry")
		path=$(list_passwords 2>/dev/null | _rofi -theme-str "$placeholder")
		assert_status $?

		pass mv "$passentry" "$path"

	elif [[ "$2" == "copy" ]]; then
		placeholder=$(wrap_placeholder "Path for $passentry copy")
		path=$(list_passwords 2>/dev/null | _rofi -theme-str "$placeholder")
		assert_status $?

		pass cp "$passentry" "$path"

	elif [[ "$2" == "delete" ]]; then
		HELP="Selected entry: ${passentry}"
		ask_content=("Yes" "No")
		placeholder=$(wrap_placeholder "Are You Sure? > ")
		ask=$(printf '%s\n' "${ask_content[@]}" |
				  _rofi -mesg "${HELP}" -theme-str "$placeholder")

		case $ask in
			"Yes") pass rm --force "${passentry}" ;;
			"No") mainMenu ;;
			*) exit ;;
		esac
	fi

	mainMenu
}

edit_pass() {
    [[ $edit_new_pass == "true" ]] && pass edit "${1}"
}

_pwgen () {
	pwgen -y "$@"
}

insertPass () {
	url=$(wl-paste)

	if [[ "${url:0:4}" == "http" ]]; then
		domain_name="$(printf '%s\n' "${url}" | awk -F / '{l=split($3,a,"."); \
			print (a[l-1]=="com"?a[l-2] OFS:X) a[l-1] OFS a[l]}' OFS=".")"
		help_content="Domain: ${domain_name}"
	else
		help_content="Hint: Copy URL to clipboard before calling this menu."
	fi

	cd "${root}" || exit

	placeholder=$(wrap_placeholder "Enter name, must be unique ... ")
	name=$(listgpg | _rofi -format 'f' -filter "${domain_name}" \
		-theme-str "$placeholder" -mesg "${help_content}" -p "> ")
	assert_status $?

	user_content=("${default_user2}" "${USER}" "${default_user}")
	placeholder=$(wrap_placeholder "Enter username")
	user=$(printf '%s\n' "${user_content[@]}" | \
		_rofi -theme-str "$placeholder" -p "> ")
	assert_status $?

	message="Type Password or hit Enter to generate one"
	placeholder=$(wrap_placeholder "Password")
	pw=$(printf '%s' "Generate" | \
		_rofi -password -theme-str "$placeholder" -mesg "$message")

	[[ $pw == "Generate" ]] && pw=$(_pwgen "${password_length}")

	clear

	pass_content=("${pw}" "---" "${USERNAME_FIELD}: ${user}")
	[[ $url == http* ]] && pass_content+=("${URL_FIELD}: ${url}")

	local pass_name="$name"

	printf '%s\n' "${pass_content[@]}" |
		pass insert -m "${pass_name}" > /dev/null && edit_pass "${pass_name}"
}

help_msg () {
	cat <<'EOF'
	Usage:
	rofi-pass [command]

	Commands:
	--insert         insert new entry to password store
	--root           set custom root directories (colon separated)
	--bmarks         start in bookmarks mode

	rofi-pass version 1.5.3
EOF
}

get_config_file () {
	configs=(
		"$ROFI_PASS_CONFIG"
		"$config_dir/rofi-pass/config"
		"/etc/rofi-pass.conf"
	)

	# return the first config file with a valid path
	for config in "${configs[@]}"; do
		# '-n' is needed in case ROFI_PASS_CONFIG is not set
		if [[ -n "${config}" && -f "${config}" ]]; then
			printf "%s" "$config"
			return
		fi
	done
}

# FIXME: either don't globalise or make the roots logic more clear
set_roots () {
	if [[ -n "$2" && "$1" == "--root" ]]; then
		custom_root=true; IFS=: read -r -a roots <<< "$2"
	elif [[ -n ${PASSWORD_STORE_DIR} ]]; then
		roots=("${PASSWORD_STORE_DIR}")
	else
		roots=("$HOME/.password-store")
	fi
	roots_index=0
	roots_length=${#roots[@]}
	export root=${roots[$roots_index]}
	export PASSWORD_STORE_DIR="${root}"
}

main () {
	# load config file
	config_file="$(get_config_file)"
	[[ -n "$config_file" ]] && source "$config_file"

	# check for BROWSER variable, use xdg-open as fallback
	[[ -z $BROWSER ]] && export BROWSER=xdg-open

	# if user has defined his own editor in config file - use it for this script
	[[ -n $EDITOR ]] && export EDITOR=$EDITOR

	set_roots "$@"

	case $1 in
		--insert) insertPass ;;
		--root) mainMenu ;;
		--help) help_msg ;;
		--bmarks) mainMenu --bmarks; ;;
		*) mainMenu ;;
	esac
}

main "$@"
