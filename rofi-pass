#!/usr/bin/env bash

# rofi-pass
# (c) 2015 Rasmus Steinke <rasi@xssn.at>

###############################################################################
#              Config defaults (in case user doesn't copies one)              #
###############################################################################

# Set alternative password store dirs. Use ":" to separate multiple roots.
# Can be switched at runtime with with corresponding hotkeys
# ROOTS=/path/to/root_one:/path/to/root_two

# You can define password store env vars here and they will be sourced in
# the script and applied to all pass commands called. Like:
# PASSWORD_STORE_CLIP_TIME=30
# PASSWORD_STORE_GENERATED_LENGTH=13

# Same way you can define other env vars that pass is using:
# EDITOR='vim -x'
# BROWSER= # defaults to 'xdg-open' if absent

# Fields to be used
URL_FIELD='url'
USERNAME_FIELD='user'
AUTOTYPE_FIELD='autotype'
OTPMETHOD_FIELD='otp_method'

BACK_OPTION='< back'

# delay to be used for :delay keyword
delay=2
# rofi-pass needs to close itself before it can type passwords. Set delay here.
wait=0.2
# delay between keypresses when typing (in ms)
type_delay=12

## Options for generating new password entries
# open new password entries in editor
edit_new_pass="true"
# set to ':basename' for user field to be set to password file name
default_user="$(whoami)"
default_user2=""

## Misc settings

default_autotype="user :tab pass"
auto_enter='false'
notify='false'

# default shortcuts
help="Alt+h"

kb_type_menu="Alt+t"
kb_type_pass="Alt+P"
kb_type_user="Alt+U"
kb_type_otp="Alt+O"
kb_autotype="Alt+A"

kb_copy_menu="Alt+c"
kb_copy_pass="Alt+p"
kb_copy_user="Alt+u"
kb_copy_url="Alt+l"

kb_create="Alt+n"
kb_read="Alt+o"
kb_update="Alt+a" # and delete

kb_open_url="Alt+4"
kb_qrcode="Alt+q"
kb_previous_root="Alt+bracketleft" # [
kb_next_root="Alt+bracketright" # ]

# --- User redefinable functions ---

_rofi () { rofi -no-auto-select -i -dmenu "$@"; }

_notify() { notify-send -e "rofi-pass" "$1"; }

# REVIEW: not sure about --clip flag
_generate_pass() { pass generate --clip --in-place "$@" > /dev/null; }


###############################################################################
#                               Action functions                              #
###############################################################################

mainMenu () {
	args=(
		# Same sequence as in above config section !
		-kb-custom-1 "${help}"

		-kb-custom-2 "${kb_type_menu}"
		-kb-custom-3 "${kb_type_pass}"
		-kb-custom-4 "${kb_type_user}"
		-kb-custom-5 "${kb_type_otp}"
		-kb-custom-6 "${kb_autotype}"

		-kb-custom-7 "${kb_copy_menu}"
		-kb-custom-8 "${kb_copy_pass}"
		-kb-custom-9 "${kb_copy_user}"
		-kb-custom-10 "${kb_copy_url}"

		-kb-custom-11 "${kb_create}"
		-kb-custom-12 "${kb_read}"
		-kb-custom-13 "${kb_update}"

		-kb-custom-14 "${kb_open_url}"
		-kb-custom-15 "${kb_qrcode}"
		-kb-custom-16 "${kb_previous_root}"
		-kb-custom-17 "${kb_next_root}"
	)

	local placeholder
	placeholder=$(wrap_placeholder  "Current store: $PASSWORD_STORE_DIR")
	args+=(-theme-str "$placeholder")

	local passentry
	passentry="$(passls | _rofi "${args[@]}")"

	rofi_exit=$?

	# Actions that do not need the entry.
	# The exit code for -kb-custom-X is X+9.
	case $rofi_exit in
		1) exit ;;
		10) helpMenu; return;;
		25) # next root
			roots_length=${#roots[@]}
			root_index=$(( (root_index-1+roots_length) % roots_length))
			PASSWORD_STORE_DIR=${roots[$root_index]}
			mainMenu
			return
			;;
		26) # previous root
			roots_length=${#roots[@]}
			root_index=$(( (root_index+1) % roots_length))
			PASSWORD_STORE_DIR=${roots[$root_index]}
			mainMenu
			return
			;;
	esac

	declare -A fields_map
	populate_fields_map "$passentry"

	# Actions that do need the entry
	# The exit code for -kb-custom-X is X+9.
	case "${rofi_exit}" in
		0 | 11) type "$passentry" 'menu' ;;
		12) type "$passentry" 'pass' ;;
		13) type "$passentry" "$USERNAME_FIELD" ;;
		14) type "$passentry" 'OTP' ;;
		15) type "$passentry" "$AUTOTYPE_FIELD" ;;

		16) copy 'menu' ;;
		17) copy 'pass' ;;
		18) copy $USERNAME_FIELD ;;
		19) copy $URL_FIELD ;;

		20) createEntry ;;
		21) showEntry ;;
		22) updateEntry "$passentry";;

		23) openURL "$passentry" ;;
		24) generateQrCode "$passentry" ;;
	esac

	unset fields_map
}

# Use func() () so the inner vars & funcs remain within this subshell
type() (
	local passentry="$1"
	local field="$2"

  [[ -z "${fields_map["${AUTOTYPE_FIELD}"]}" && -n $default_autotype ]] &&
    fields_map["${AUTOTYPE_FIELD}"]="${default_autotype}"

	do_type() { sleep $wait; wtype -d ${type_delay} - ; }

	autotype () {
		do_press_key() { wtype -k "$1"; }

		for word in ${fields_map["$AUTOTYPE_FIELD"]}; do
			case "$word" in
				":tab") do_press_key Tab ;;
				":space") do_press_key space ;;
				":delay") sleep "${delay}" ;;
				":enter") do_press_key Return ;;
				":otp") printf '%s' "$(generateOTP "$passentry")" | do_type ;;
				"pass") printf '%s' "${fields_map[pass]}" | do_type ;;
				"path")
					printf '%s' "${passentry}" | rev | cut -d'/' -f1 | rev | do_type
					;;
				# Also handles non-existant fields prompt by just entering nothing
				*) printf '%s' "${fields_map[${word}]}" | do_type ;;
			esac
		done

		[[ ${auto_enter} == "true" ]] && do_press_key Return
	}

	case "$field" in
		# doubt anyone will ever have 'menu' field in their pass file
		"menu")
			local sorted_fields=()
			mapfile -t sorted_fields < <(get_sorted_fields)
			sorted_fields+=("${AUTOTYPE_FIELD}")

			placeholder=$(wrap_placeholder "Field to autotype")
			field=$(printf '%s\n' "${sorted_fields[@]}" |
						    _rofi -theme-str "$placeholder")
			assert_status $?

			type "$passentry" "$field"
			;;
		"$USERNAME_FIELD") printf '%s' "${fields_map[${USERNAME_FIELD}]}" | do_type ;;
		pass) printf '%s' "${fields_map[pass]}" | do_type ;;
		"OTP") printf '%s' "$(generateOTP "$passentry")" | do_type ;;
		"$AUTOTYPE_FIELD") autotype ;;
		*) printf '%s' "${fields_map[${field}]}" | do_type ;;
	esac
)

generateQrCode() {
	local passentry="$1"
	local qrcode_path="$HOME/.cache/rofi/temp_pass_qr.png"

	has_qrencode() { command -v qrencode >/dev/null 2>&1; }

	if ! has_qrencode; then
		printf '%s\n' "qrencode not found" | _rofi
		assert_status $?
		mainMenu
	fi

	pass "$passentry" | head -n 1 |
		qrencode -t png -o "$qrcode_path" -l H -s 25 -m 2 --dpi=192 -v 8

	_rofi -theme-str "
entry{enabled:false;}
textbox-prompt-colon{str:\"\";}
window{
  border-radius:6mm; padding:1mm; width:100mm; height:100mm;
  background-image:url(\"$qrcode_path\",both);
}"
	rm -f "$qrcode_path"
}

openURL () {
	local passentry="$1"
	url=$(pass "$passentry" | grep "${URL_FIELD}: " | cut -d' ' -f 2)
	if [ -z "$url" ]; then
	 notify_w "No $URL_FIELD field in $passentry"
	 exit
	fi
	$BROWSER "$url"
}

generateOTP () {
	local passentry="$1"

	# First, we check if there is a non-conventional OTP command in the pass file
	_check_otp_cmd() {
		pass "$passentry" | grep -q "${OTPMETHOD_FIELD}: "
	}

	if _check_otp_cmd; then
		# We execute the commands after otp_method: AS-IS
		bash -c "$(_check_otp_cmd)"
	else
		# If there is no method defined, fallback to pass-otp
		pass otp "$passentry"
	fi
}

copy() {
	local field="$1"
	local passentry="$2" # is not always passed

	case $field in
		# i doubt anyone will have 'menu' field in their password file
		menu)
			local sorted_fields=()
			mapfile -t sorted_fields < <(get_sorted_fields)
			placeholder=$(wrap_placeholder "Field to copy")
			field=$(printf '%s\n' "${sorted_fields[@]}" | sort |
							  _rofi -theme-str "$placeholder")

			assert_status $?

			copy "$field"
		  ;;
		"pass")
			pass -c "$passentry"
			notify_w "Copied $field field\nClearing in ${PASSWORD_STORE_CLIP_TIME:-45} seconds"
			;;
		*) printf '%s' "${fields_map[$field]}" | wl-copy &&
				 notify_w "Copied $field field" ;;
	esac
}

# receives current password entry as a parameter
updateEntry () {
	local move="Move"
	local copy="Copy"
	local delete="Delete"
	local edit="Edit"
	local generate="Generate new"

	actions=("$move" "$copy" "$delete" "$edit" "$generate" "$BACK_OPTION")

	placeholder=$(wrap_placeholder "Choose action")
	action=$(printf '%s\n' "${actions[@]}" | _rofi -theme-str "$placeholder")

	case $action in
		"$move") manageEntry "$1" move ;;
		"$delete") manageEntry "$1" delete ;;
		"$copy") manageEntry "$1" copy ;;
		"$edit") manageEntry "$1" edit ;;
		"$generate") generatePass "$1" ;;
		"$BACK_OPTION") mainMenu ;;
		*) exit ;;
	esac
}

manageEntry () {
	local passentry="$1"

	if [[ "$2" == "edit" ]]; then
		pass edit "${passentry}"
	elif [[ "$2" == "move" ]]; then
		placeholder=$(wrap_placeholder "New path for $passentry")
		path=$(passls | _rofi -theme-str "$placeholder")
		assert_status $?

		notify_w "Moving $passentry to $path ..."
		if pass mv "$passentry" "$path"; then
			notify_w "Successfully moved $passentry to $path"
		else
			notify_w "Failed to move $passentry to $path"
		fi

	elif [[ "$2" == "copy" ]]; then
		placeholder=$(wrap_placeholder "Path for $passentry copy")
		path=$(passls | _rofi -theme-str "$placeholder")
		assert_status $?

		notify_w "Copying $passentry to $path ..."
		if pass cp "$passentry" "$path"; then
			notify_w "Successfully copied $passentry to $path"
		else
			notify_w "Failed copying $passentry to $path"
		fi

	elif [[ "$2" == "delete" ]]; then
		ask_content=("yes" "no")
		placeholder=$(wrap_placeholder "Delete $passentry?")
		ask=$(printf '%s\n' "${ask_content[@]}" | _rofi -theme-str "$placeholder")
		assert_status $?

		case $ask in
			"yes")
				notify_w "Deleting $passentry ..."
				if pass rm --force "$passentry"; then
					notify_w "Successfully deleted $passentry"
				else
					notify_w "Failed to delete $passentry"
				fi
				;;
			"no") mainMenu ;;
			*) exit ;;
		esac
	fi

	mainMenu
}

generatePass () {
	local passentry="$1"

	placeholder=$(wrap_placeholder "Password length (leave empty for pass default):")
	length=$(printf '%s' "" | _rofi -theme-str "$placeholder")
	assert_status $?

	notify_w "Generating and saving new passwrod for $passentry"

	if _generate_pass "$passentry" "$length"; then
		notify_w "Successfully generated new password for $passentry"
	else
		notify_w "Failed to generate nwe password for $passentry"
	fi
}

showEntry () {
	local content
	local -a lines
	for key in "${!fields_map[@]}"; do lines+=("${key}: ${fields_map[$key]}"); done

	content=("$(printf '%s\n' "${lines[@]}")" "$BACK_OPTION" )
	placeholder=$(wrap_placeholder "Enter: copy entry to clipboard")
	selection=$(printf '%s\n' "${content[@]}" | _rofi -theme-str "$placeholder" -p "> ")
	assert_status $?

	field=$(printf '%s' "$selection" | cut -d':' -f 1)

	case $field in
		"$BACK_OPTION") mainMenu ;;
		*) copy "$field" ;;
	esac

	exit
}

createEntry () {
	url=$(wl-paste)

	if [[ "${url:0:4}" == "http" ]]; then
		domain_name="$(printf '%s\n' "${url}" | awk -F / '{l=split($3,a,"."); \
			print (a[l-1]=="com"?a[l-2] OFS:X) a[l-1] OFS a[l]}' OFS=".")"
		help_content="Url: ${domain_name}"
	else
		help_content="Hint: Copy URL to clipboard before calling this menu."
	fi

	# needs to be checked here since this f-n may be called directly from 'main'
	cd "$PASSWORD_STORE_DIR" || exit

	placeholder=$(wrap_placeholder "Enter name, must be unique ...")
	path=$(passls | _rofi -format 'f' -filter "${domain_name}" \
		-theme-str "$placeholder" -mesg "${help_content}" -p "> ")
	assert_status $?

	if [ -z "$path" ]; then
		notify_w "No empty path allowed"
		createEntry
		exit
	fi


	local _user="$default_user"
	[[ "$_user" == ":basename" ]] && _user="$(basename "$path")"

	users=("$_user" "${USER}")
	[ -n "$default_user2" ] && users+=("$default_user2")
	placeholder=$(wrap_placeholder "Enter username ...")
	user=$(printf '%s\n' "${users[@]}" | _rofi -theme-str "$placeholder")
	assert_status $?

	placeholder=$(wrap_placeholder "Type password or hit Enter to generate one")
	pw=$(printf '%s' "Generate" | _rofi -password -theme-str "$placeholder")
	assert_status $?

	pass_content=("${pw}" "${USERNAME_FIELD}: ${user}")
	[[ $url == http* ]] && pass_content+=("${URL_FIELD}: ${url}")

	notify_w "Creating password entry $path ..."
	printf '%s\n' "${pass_content[@]}" | pass insert -m "${path}" > /dev/null

	if [ $? == 0 ]; then
		[[ $pw == "Generate" ]] && _generate_pass "$path"
		[[ $edit_new_pass == "true" ]] && pass edit "${path}"
		notify_w "Password entry $path successfully created"
	else
		notify_w "Failed to create new password entry $path. Is password store initialized?"
	fi
}

helpMenu () {
	local placeholder
	placeholder=$(wrap_placeholder "Hint: All hotkeys are configurable in config file")
	_rofi -theme-str "$placeholder" -mesg "Press Return to exit this menu" <<- EOM
	${kb_type_menu}: Open 'type' submenu
	${kb_type_pass}: Type password
	${kb_type_user}: Type username
	${kb_type_otp}: Type OTP
	${kb_autotype}: Autotype based on '$AUTOTYPE_FIELD' field contents (defaults to '$default_autotype')
	---
	${kb_copy_menu}: Open 'copy' submenu
	${kb_copy_pass}: Copy password
	${kb_copy_user}: Copy username
	${kb_copy_url}: Copy URL
	---
	${kb_create}: Create new pass entry
	${kb_read}: Show pass entry
	${kb_update}: Edit, copy, move, delete, generate submenu
	---
	${kb_open_url}: Open URL
	${kb_qrcode}: Generate and display qrcode
	${kb_previous_root}: Switch to previous password store root
	${kb_next_root}: Switch to next password store root
EOM

	assert_status $?

	mainMenu
}


###############################################################################
#                               Helper functions                              #
###############################################################################

# convenience _notify wrapper to skip all those checks everywhere
notify_w() {
	notify_on && _notify "$1"
}

notify_on() {
	if [[ $notify == "true" ]]; then
		return 0
	else
		return 1
	fi
}

assert_status() { [ "$1" -eq 1 ] && exit; }

# Is called only in mainMenu, populates 'fields_map' var that is visible to all
# function that mainMenu calls.
populate_fields_map() {
	local passentry="$1"

	# check if user propmt exists in the store
	output=$(pass show "$passentry" 2>&1)
	[ "$?" -eq 1 ] && notify_w "$output" && exit
	
	# get an array of password file fields like url: user: and custom ones
	local -a password_temp
	mapfile -t password_temp < <(pass show "$passentry")

	fields_map["pass"]=${password_temp[0]}

	# checks if the first field ($1) of the input line ends with a colon (:$) or
	# if the line contains the string otpauth://. If either condition is true,
	# the action block associated with this condition is executed
	fields=$(printf '%s\n' "${password_temp[@]:1}" |
				     awk '$1 ~ /:$/ || /otpauth:\/\// {$1=$1;print}')
	unset password_temp

	if [[ -n $fields ]]; then
		while read -r LINE; do
			unset _id _val
			case "$LINE" in
				"otpauth://"* | "${OTPMETHOD_FIELD}"*)
					_id="OTP"
					_val=""
					;;
				*)
					_id="${LINE%%: *}"
					_val="${LINE#* }"
					;;
			esac

			[[ -n "$_id" ]] && fields_map["${_id}"]=${_val}
		done < <(printf '%s\n' "${fields}")

		if test "${fields_map['autotype']+autotype}"; then
			:
		else
			fields_map["autotype"]="${USERNAME_FIELD} :tab pass"
		fi
	fi

	if [[ -z "${fields_map["${USERNAME_FIELD}"]}" && -n $default_user ]]; then
		if [[ "$default_user" == ":basename" ]]; then
			fields_map["${USERNAME_FIELD}"]="$(basename "$passentry")"
		else
			fields_map["${USERNAME_FIELD}"]="${default_user}"
		fi
	fi

}

# get all password files and output as newline-delimited text
passls() {
	cd "$PASSWORD_STORE_DIR" || return 1

	mapfile -d '' pw_list < <(find -L . -name '*.gpg' -print0)
	pw_list=("${pw_list[@]#./}")
	printf '%s\n' "${pw_list[@]%.gpg}" | sort | grep -v "^$"
	return 0
}

# FIXME: how to move the '-theme-str' part in this funciton
wrap_placeholder() { echo "#entry { placeholder: \"$1\"; }"; }

# Returns sorted keys for current password entry with 'autotype' key removed.
# Fields like 'user', 'url', etc
get_sorted_fields() {
	local -a keys=("${!fields_map[@]}")
	# remove autotype field from keys array
	keys=("${keys[@]/$AUTOTYPE_FIELD}")
	# grep out empty strings cuz command above doesn't update indecies
	printf '%s\n' "${keys[@]}" | sort | grep -v "^$"
}

help_msg () {
	cat <<'EOF'
	Usage:
	rofi-pass [command]

	Commands:
	--create         create new entry to password store
	--roots          set custom root directories (colon separated)
EOF
}


###############################################################################
#                             Main function logic                             #
###############################################################################

# sources the first config file with a valid path
load_config () {
	local config_dir=${XDG_CONFIG_HOME:-$HOME/.config}
	local -a configs=(
		"$ROFI_PASS_CONFIG"
		"$config_dir/rofi-pass/config"
		"/etc/rofi-pass.conf"
	)

	for config in "${configs[@]}"; do
		# '-n' is needed in case ROFI_PASS_CONFIG is not set
		if [[ -n "${config}" && -f "${config}" ]]; then
			source "$config"
			return
		fi
	done
}

populate_roots () {
	local IFS=:

	# Precedense: flag -> config -> pass DIR var -> default $HOME/.password-store
	if [[ "$1" == "--root" && -n "$2" ]]; then
		read -r -a roots <<< "$2"
	elif [[ -n "$ROOTS" ]]; then # config var
    read -r -a roots <<< "$ROOTS"
	elif [[ -n $PASSWORD_STORE_DIR ]]; then
		roots=("$PASSWORD_STORE_DIR")
	else
		# NOTE: need to hardcode at least one default root since we need to cd
		# somewhere to find all password entries
		roots=("$HOME/.password-store")
	fi
}

main () {
	load_config

	# check for BROWSER variable, use xdg-open as fallback
	[[ -z $BROWSER ]] && BROWSER=xdg-open

	declare -a roots
	declare root_index=0
	populate_roots "$@"
	PASSWORD_STORE_DIR=${roots[$root_index]}

	# TODO: see which flags make sence to be added here instead of deprecated
	# 'default_do'
	# menu, copy menu, type menu, showEntry, actionMenu, openUrl
	case $1 in
		--create) createEntry ;;
		--help | -h) help_msg ;;
		*) mainMenu ;;
	esac
}

main "$@"

# TODO: instead of previous bookmarks functionality utilize 'pass grep $url_field'
# to grep and output all urls of the password store and on enter open them
